# 位运算技巧在算法设计中的应用

Author: Yanrui Hu
Date: 2022-09-22
Description: The usage of bitwise operation tricks in algorithm design.
Keyword: bitwise operation, tricks, Magic

写作的目的就是整理知识，强化记忆，以备不时之需

-------------------------------------

## 位运算符的种类 (Sorts of bitwise operators)

以下的排列顺序按照运算符的优先级 *(Operator precedence)* 自高至低

- 按位取反 ~ {唯一的单目运算符, 单目的优先级比双目的高} **[Bitwise NOT]**
- 按位左移 << **[Left Shift]**
- 按位右移 >> **[Sign-propagating right shift]**
- 按位无符号右移 <<< **[Zero-fill right shift]**
- 按位与 & **[Bitwise AND]**
- 按位异或 ^ **[Bitwise XOR]**
- 按位或 | **[Bitwise OR]**

> [参考资料: MDN Operator_Precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

## 位运算表达式的构造和解释 (bitwise-operation-expressions' structure and interpretation)
(这一部分需要持续性整理,不断积累各种用法)

### Part 1

- 乘法运算转化成位运算 (在不产生溢出的情况下)
  a << n (a 乘以 2的 n次幂， a * 2 ** n)

- 除法运算转化成位运算 (在不产生溢出的情况下)
  a >> n  (a 除以 2的 n次幂， a / (2 ** n) )

- 取模运算转化成位运算 (在不产生溢出的情况下)
  a & ((1 << n) -1) (2的整数次幂减去一可以得到二进制形式全为 1 的数字， a & ($2^n - 1$))

- 判断 int型变量a 是奇数还是偶数
  a & 1   = 0 偶数
  a & 1   = 1 奇数

- 取 int型变量a的 第k位 (k=0,1,2……sizeof(int))
  a >> k & 1
  等价形式：
  - (a >> k) & 1

- 将int型变量a的第k位 置0
  a &= ~(1 << k)
  等价形式:
  - a = a & ~(1 << k)
  扩展：
  - 将 a 的第4~9位 置 0
    a &= ~(0x3F << 4)

- 将int型变量a的第k位 置1
  a |= 1 << k
  等价形式：
  - a = a | (1 << k)
  扩展：
  - 将 a 的第4~9位 置1
    a |= 0x3F << 4

- 将int型变量a的第k位 翻转
  a ^= (1 << k)
  等价形式:
  - a = a ^ (1 << k)

- 整数的平均值
  (x&y) + ((x^y) >> 1)
  另一种方法：(x + (y-x)) >> 1

- 判断一个整数是不是2的幂,对于一个数 x >= 0
  return ((x & (x-1)) == 0) && (x != 0)；

- 用位运算符交换两个整数
  x ^= y;
  y ^= x;
  x ^= y;

- 计算x的绝对值
  int y = x >> 31; // y 代表 x的符号位
  return (x ^ y ) - y;

- x 的 相反数
  (~x + 1)

- 消除数字 n 的二进制表示中的`最后一个1`
  n & (n - 1)
  举例：
  n 等于 0b1001100时
  n & (n-1) == 0b1001000




### Part 2

- num ^ 1
  把 `异或1` 看做一种一元操作, 如果 num == 0,  num ^ 1 得到 1
  如果 num == 1, num ^ 1 得到 0
  此时，我们从变化的视角看待异或1这种操作
  这种操作的作用是实现`翻转`, 起到把1变0，把0变1的效果
  同时我们知道了`异或0`这种一元操作的效果是`不变`,原来的是啥结果就是啥
  如果num 不仅限于 0 和 1，例如num = 0b100110
  num ^= 1 也就是 num ^= 0b000001, 所以这个表达式的效果是`把 num 的最后一位进行翻转`
  继续下去，我们看
  num ^= (1 << i)
  解释： 在i不超过一定范围的时候，这个表达式的效果是`把 num 的右起第 i 位进行翻转`
  为了方便记忆，可以把 `^= (1<< n)` 想象成炮弹，1 打到哪里，哪里就会发生翻转

- 1 << n
  表示 2 的 n 次幂 $2^n$，二进制形式为 `1后面跟上n个0`

- (1 << n) - 1 *(必须有括号，二元减号的优先级比移位运算高)*
  表示 2的 n次幂 减去1： $2^n -1$ ，二进制形式为`n个1`

- s >> i & 1
  用于探测s在二进制形式下的右起第i位数字是 `1 还是 0`，该表达式的运算结果只能是 1 或者 0
  等价形式：
  - (s >> i) & 1
  - 1 & (s >> i)
  - 1 & s >> i

- s & 1 << i
  也可以用于探测，作为 bool值进行使用是，与上一种相同。但是该表达式的运算结果是2的整数次幂
  可以通过这种运算把 s 进行分解，`分解成2的整数次幂相加`
  等价形式:
  - s & (1 << i)
  - (1 << i) & s
  - 1 << i & s

- s ^ (1 << i)
  `把数字 s 的右起第 i 位进行翻转`
  首先 `(1 << i)` 表示2的i次幂，即`1后面跟上i个0`.
  假设 `s 由 n 个 1` 构成, i 的取值范围是 [0, n-1] 闭区间
  则:
  i == 0 时，原式的结果是 把 s中的右起第 0 个数字更改成 1
  i == 1 时，原式的结果是 把 s中的右起第 1 个数字更改成 1
  。。。
  所以原式的结果就是把 s 中右起第 i 个数字更改成 1 (仅限于 s 的二进制形式全为 1 的情况)
  异或运算可以看成是不进位的加法
  等价形式:
  - (1 << i) ^ s
  - 1 << i ^ s
  - s ^ 1 << i


### Part 3

- 利用`或操作 | 和空格`将英文字符`转换为小写`
  ('a' | ' ') = 'a'
  ('A' | ' ') = 'a'
  等价于：
  - Python 写法： new_ch = chr(ord(ch) | 32) *也可以写成32的十六进制形式 0x20*
  - C++: ch |= 0x20

- 利用`与操作 & 和下划线`将英文字符转换为大写
  ('b' & '_') = 'B'
  ('B' & '_') = 'B'
  等价于:
  - Python 写法: chr(ord(ch) & 95)  *也可以写成95的十六进制形式 0x5F*
  - C++: ch &= 0x5F

- 利用`异或操作 ^ 和空格`进行英文字符大小写互换
  ('d' ^ ' ') = 'D'
  ('D' ^ ' ') = 'd'
  等价于:
  - Python 写法: chr(ord(ch) ^ 32) *也可以写成32的十六进制形式 0x20*
  - C++: ch ^= 0x20
