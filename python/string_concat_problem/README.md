# 突发奇想的解法

在搜索的过程中，如果`字符串S`与 `substr` 中的某个字符串相匹配，
那就将`S`中对应的部分转换成大写字母，这样可以有效的**对搜索范围进行界定**！

举个例子：

```py
S = "xxyxxyxxyxx"
substr = ['xxyxx', 'xxy', 'yxx']
```

```py
# ---------------------------------------
    匹配 substr[0] -> 'xxyxx'
    得到 idx -> 0 => S = "XXYXXyxxyxx"
    list.append(0)
# ---------------------------------------


# ---------------------------------------
    匹配 substr[1] -> 'xxy'
    得到 idx -> 6 => S = "XXYXXyXXYxx"
    list.append(6)
# ---------------------------------------

# ---------------------------------------
    匹配 substr[2] -> 'yxx'
    得到 idx -> -1
    return False
# ---------------------------------------

# ---------------------------------------
    恢复 S = "XXYXXyxxyxx"
    list.pop() # remove 6
    ----------------------
    匹配 substr[1] -> 'xxy'
    得到 idx -> -1
    return False
# ---------------------------------------

# ---------------------------------------
    恢复 S = "xxyxxyxxyxx"
    list.pop() # remove 0
    ----------------------
    匹配 substr[0] -> 'xxyxx'
    得到 idx -> 3 => S = "xxyXXYXXyxx"
    list.append(3)
# ---------------------------------------

# ---------------------------------------
    匹配 substr[1] -> 'xxy'
    得到 idx -> 0 => S = "XXYXXYXXyxx"
    list.append(0)
# ---------------------------------------

# ---------------------------------------
    匹配 substr[2] -> 'yxx'
    得到 idx -> 8 => S = "XXYXXYXXYXX"
    list.append(8)
    由于 2 是 substr 的最后一个有效下标,
    保存此搜索路径上的 list
    set.add(tuple(sorted(list))) # 将下标序列排序后转换为元组并放在集合中可以自动去重！
    list.pop() # remove 8
    return True
# ---------------------------------------


# ---------------------------------------
    恢复 S = "xxyXXYXXyxx"
    list.pop() # remove 0
    ----------------------
    匹配 substr[1] -> 'xxy'
    得到 idx -> -1
    return False
# ---------------------------------------


# ---------------------------------------
    恢复 S = "xxyxxyxxyxx"
    list.pop() # remove 3
    ----------------------
    匹配 substr[0] -> 'xxyxx'
    得到 idx -> 6 => S = "xxyxxyXXYXX"
    list.append(6)
# ---------------------------------------

# ---------------------------------------
    匹配 substr[1] -> 'xxy'
    得到 idx -> 0 => S = "XXYxxyXXYXX"
    list.append(0)
# ---------------------------------------

# ---------------------------------------
    匹配 substr[2] -> 'yxx'
    得到 idx = -1
    return False
# ---------------------------------------

# ---------------------------------------
    恢复 S = "xxyxxyXXYXX"
    list.pop() # remove 0
    ----------------------
    匹配 substr[1] -> 'xxy'
    得到 idx = 3 => S = "xxyXXYXXYXX"
    list.append(3)
# ---------------------------------------

# ---------------------------------------
    匹配 substr[2] -> 'yxx'
    得到 idx = -1
    return False
# ---------------------------------------

# ---------------------------------------
    恢复 S = "xxyxxyXXYXX"
    list.pop() # remove 3
    ----------------------
    匹配 substr[1] -> 'xxy'
    得到 idx = -1
    return False
# ---------------------------------------

# ---------------------------------------
    恢复 S = "xxyxxyxxyxx"
    list.pop() # remove 6
    ----------------------
    匹配 substr[0] -> 'xxyxx'
    得到 idx = -1
    return False
# ---------------------------------------

# ---------------------------------------
    说明:
    可以设置一个全局的 set, 用于存储不同的裁剪方式
    len(set) 即为所求的个数
    S 和 list 可以是全局变量 (只要程序运行时不是多线程)，也可以作为函数参数进行传递
    在搜索过程中注意`备份S`，这样才能`恢复S`
    字符串匹配使用的是 python 字符串原生的 find()方法，返回值为 -1 是表示无法匹配
    可以通过 find() 的第二个参数指定开始搜索的位置，这是算法的关键
    在本算法中，list 起到的作用是 栈，这是`能够正确回溯的关键`
    set 起到的作用是`去除重复结果`
    tuple()起到的作用是`提供一个不可变序列`
    sorted() 防止因为顺序不同导致序列不同
    在搜索的过程中，函数参数至少需要包含待匹配的字符串在 substr 中的下标 i,
    下标随着调用栈的增长每次 +1，
    `当前下标 == 最后一个下标`说明当前已经达到搜索的终点 (叶节点)
# ---------------------------------------

```
